# .github/workflows/deploy.yml

name: Build with Bazel, Deploy with Fastlane

# Trigger this workflow on every push to the 'main' branch
on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    name: Build and Deploy to TestFlight
    runs-on: macos-latest

    steps:
      # 1. Checkout the repository code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Cache Xcode derived data for faster builds
      - name: Cache Xcode derived data
        uses: actions/cache@v4
        with:
          path: ~/Library/Developer/Xcode/DerivedData
          key: ${{ runner.os }}-xcode-deriveddata-${{ hashFiles('**/project.pbxproj') }}
          restore-keys: |
            ${{ runner.os }}-xcode-deriveddata-

      # 3. Select the version of Xcode to use
      # Required by Bazel's iOS build rules.
      - name: Select Xcode version
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.2.0'

      # 4. Clean build artifacts to ensure fresh build
      - name: Clean Xcode build artifacts
        run: |
          echo "ðŸ§¹ Cleaning previous build artifacts..."
          rm -rf CrossSumsSimple.xcarchive
          rm -f *.ipa
          echo "âœ… Clean completed"

      # 4.1. Install iOS Distribution Certificate for Code Signing
      # This step installs the certificate directly into the system keychain for Bazel sandbox access
      - name: Install iOS Distribution Certificate
        env:
          IOS_DIST_SIGNING_KEY: ${{ secrets.IOS_DIST_SIGNING_KEY }}
          IOS_DIST_SIGNING_KEY_PASSWORD: ${{ secrets.IOS_DIST_SIGNING_KEY_PASSWORD }}
        run: |
          echo "ðŸ” Installing certificate into system keychain for Bazel sandbox access..."
          
          # Create variable for certificate path
          CERTIFICATE_PATH=$RUNNER_TEMP/ios_distribution.p12
          
          # Decode base64 certificate and save to file
          echo "ðŸ“„ Decoding certificate from secrets..."
          echo -n "$IOS_DIST_SIGNING_KEY" | base64 --decode -o $CERTIFICATE_PATH
          
          # Import certificate directly into system keychain with codesign tool access
          echo "ðŸ“¥ Installing certificate into system keychain..."
          sudo security import $CERTIFICATE_PATH -k /Library/Keychains/System.keychain -P "$IOS_DIST_SIGNING_KEY_PASSWORD" -T /usr/bin/codesign
          
          # Verify certificate installation and show detailed certificate information
          echo "âœ… Verifying certificate installation and type..."
          
          # Show all codesigning identities with full details
          echo "ðŸ“‹ All available codesigning identities:"
          security find-identity -v -p codesigning
          
          # Extract certificate details to check type
          echo "ðŸ” Analyzing installed certificate type..."
          TEMP_CERT_PATH=$RUNNER_TEMP/cert_for_analysis.pem
          openssl pkcs12 -in $CERTIFICATE_PATH -clcerts -nokeys -out $TEMP_CERT_PATH -passin pass:"$IOS_DIST_SIGNING_KEY_PASSWORD"
          INSTALLED_CERT_SUBJECT=$(openssl x509 -in $TEMP_CERT_PATH -noout -subject)
          INSTALLED_CERT_TYPE=$(echo "$INSTALLED_CERT_SUBJECT" | sed -n 's/.*CN = \([^,]*\).*/\1/p')
          
          # Debug: Show what we extracted
          echo "ðŸ› DEBUG - Subject: $INSTALLED_CERT_SUBJECT"
          echo "ðŸ› DEBUG - Extracted Type: '$INSTALLED_CERT_TYPE'"
          
          echo "ðŸ“„ Installed Certificate Details:"
          echo "Subject: $INSTALLED_CERT_SUBJECT"
          echo "Certificate Type: $INSTALLED_CERT_TYPE"
          
          # Check if it's the correct type for TestFlight
          if echo "$INSTALLED_CERT_TYPE" | grep -q "iPhone Distribution"; then
            echo "âœ… SUCCESS: Certificate type is 'iPhone Distribution' - correct for TestFlight"
          elif echo "$INSTALLED_CERT_TYPE" | grep -q "iPhone Developer"; then
            echo "âŒ ERROR: Certificate type is 'iPhone Developer' - TestFlight requires 'iPhone Distribution'"
            echo "Please export the iOS Distribution certificate from Keychain Access, not the Developer certificate"
            exit 1
          elif echo "$INSTALLED_CERT_TYPE" | grep -q "Apple Distribution"; then
            echo "âœ… SUCCESS: Certificate type is 'Apple Distribution' - correct for TestFlight"
          else
            echo "âš ï¸  WARNING: Unrecognized certificate type: $INSTALLED_CERT_TYPE"
          fi
          
          # Clean up certificate files
          rm -f $CERTIFICATE_PATH $TEMP_CERT_PATH
          
          echo "ðŸŽ‰ Certificate type verification completed!"

      # 4.2. Analyze provisioning profile and verify certificate compatibility
      - name: Verify certificate and provisioning profile compatibility
        run: |
          echo "ðŸ” Analyzing provisioning profile and certificate compatibility..."
          
          PROVISIONING_PROFILE_PATH="CrossSumsSimple/CrossSumsSimple_AppStore.mobileprovision"
          
          # Extract provisioning profile contents
          echo "ðŸ“„ Extracting provisioning profile contents..."
          security cms -D -i "$PROVISIONING_PROFILE_PATH" > /tmp/profile.plist
          
          # Show provisioning profile details
          echo "ðŸ“‹ Provisioning Profile Details:"
          echo "Name: $(/usr/libexec/PlistBuddy -c 'Print Name' /tmp/profile.plist)"
          echo "Team ID: $(/usr/libexec/PlistBuddy -c 'Print TeamIdentifier:0' /tmp/profile.plist)"
          echo "Bundle ID: $(/usr/libexec/PlistBuddy -c 'Print Entitlements:application-identifier' /tmp/profile.plist)"
          echo "Expiry: $(/usr/libexec/PlistBuddy -c 'Print ExpirationDate' /tmp/profile.plist)"
          
          # Extract certificate identity from provisioning profile
          echo "ðŸ” Expected Certificate Identity from Provisioning Profile:"
          /usr/libexec/PlistBuddy -c 'Print DeveloperCertificates:0' /tmp/profile.plist > /tmp/cert.der
          PROVISIONING_CERT_SUBJECT=$(openssl x509 -inform DER -noout -subject -in /tmp/cert.der)
          EXPECTED_IDENTITY=$(echo "$PROVISIONING_CERT_SUBJECT" | sed 's/.*CN = \([^,]*\).*/\1/')
          
          # Debug: Show what we extracted
          echo "ðŸ› DEBUG - Provisioning Subject: $PROVISIONING_CERT_SUBJECT"
          echo "ðŸ› DEBUG - Extracted Identity: '$EXPECTED_IDENTITY'"
          echo "Expected: $EXPECTED_IDENTITY"
          
          # Show available certificates in keychain
          echo "ðŸ”‘ Available Signing Identities in Keychain:"
          security find-identity -v -p codesigning
          
          # Check if expected identity is available
          echo "âœ… Checking certificate compatibility..."
          if security find-identity -v -p codesigning | grep -q "$EXPECTED_IDENTITY"; then
            echo "âœ… SUCCESS: Found matching certificate identity in keychain!"
            echo "CERTIFICATE_IDENTITY=$EXPECTED_IDENTITY" >> $GITHUB_ENV
          else
            echo "âŒ ERROR: Expected certificate identity not found in keychain!"
            echo "Expected: $EXPECTED_IDENTITY"
            echo "Available identities:"
            security find-identity -v -p codesigning
            exit 1
          fi
          
          # Clean up temporary files
          rm -f /tmp/profile.plist /tmp/cert.der
          echo "ðŸŽ¯ Certificate verification completed successfully!"

      # 5. Build and Archive with xcodebuild (replacing Bazel)
      # xcodebuild properly processes asset catalogs and generates required icon files
      - name: Build and Archive with xcodebuild
        run: |
          echo "ðŸ—ï¸ Building and archiving with xcodebuild..."
          
          # Archive the project
          xcodebuild -project "CrossSumsSimple.xcodeproj" \
            -scheme "Simple Cross Sums" \
            -destination "generic/platform=iOS" \
            -archivePath "CrossSumsSimple.xcarchive" \
            CODE_SIGN_IDENTITY="$CERTIFICATE_IDENTITY" \
            PROVISIONING_PROFILE_SPECIFIER="CrossSumsSimple_AppStore" \
            DEVELOPMENT_TEAM="J4QUKKF6V3" \
            archive
          
          echo "âœ… Archive completed successfully"
          
          # Export IPA for TestFlight
          echo "ðŸ“¦ Exporting IPA for TestFlight..."
          xcodebuild -exportArchive \
            -archivePath "CrossSumsSimple.xcarchive" \
            -exportPath "." \
            -exportOptionsPlist "exportOptions.plist"
          
          echo "âœ… IPA export completed"

      # 5.1. Debug - List xcodebuild output to verify IPA location  
      - name: Debug - List xcodebuild output
        run: |
          echo "Current directory: $(pwd)"
          echo "Archive contents:"
          ls -la CrossSumsSimple.xcarchive/ 2>/dev/null || echo "Archive not found"
          echo "Export directory contents:"
          ls -la . | grep -E "\.(ipa|app)$" || echo "No IPA files found in current directory"
          echo "Looking for IPA files recursively:"
          find . -name "*.ipa" -type f 2>/dev/null || echo "No .ipa files found"

      # 6. Setup Ruby and Fastlane
      # This installs Ruby and your project's gems (like fastlane) from the Gemfile.
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler: '2.4'
          working-directory: ./fastlane # Specifies where to find the Gemfile

      # 7. Install Fastlane gems (explicit step to ensure they're available)
      - name: Install Fastlane gems
        working-directory: ./fastlane
        run: bundle install

      # 7.1. Find and set IPA path from xcodebuild export
      - name: Find IPA file and set path
        id: find_ipa
        run: |
          echo "=== IPA File Discovery for xcodebuild Export ==="
          echo "Current directory: $(pwd)"
          
          # xcodebuild exports to current directory with app name
          # Look for the exported IPA file
          IPA_FILE=$(find . -maxdepth 2 -name "*.ipa" -type f | head -1)
          
          if [ -n "$IPA_FILE" ]; then
            echo "âœ… Found IPA file: $IPA_FILE"
            echo "IPA_PATH=$IPA_FILE" >> $GITHUB_OUTPUT
            
            # Show IPA file details
            echo "ðŸ“Š IPA file details:"
            ls -lh "$IPA_FILE"
            exit 0
          fi
          
          # Fallback - search more broadly
          echo "No IPA found in current directory, searching recursively..."
          IPA_FILE=$(find . -name "*.ipa" -type f 2>/dev/null | head -1)
          
          if [ -n "$IPA_FILE" ]; then
            echo "âœ… Found IPA using recursive search: $IPA_FILE"
            echo "IPA_PATH=$IPA_FILE" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Debug information if not found
          echo "âŒ No IPA file found!"
          echo "=== Debug Information ==="
          echo "Current directory contents:"
          ls -la
          echo "Looking for any files with 'ipa' in name:"
          find . -type f -name "*ipa*" 2>/dev/null || echo "No files with 'ipa' in name found"
          exit 1

      # 7.2. Run Fastlane to Deploy
      # This step runs inside the `./fastlane` directory.
      - name: Upload to TestFlight
        working-directory: ./fastlane
        env:
          # Secrets for authenticating with App Store Connect
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY_CONTENT }}
          
          # Pass the dynamically found IPA path as absolute path to avoid relative path issues
          FASTLANE_IPA_PATH: ${{ github.workspace }}/${{ steps.find_ipa.outputs.IPA_PATH }}
        run: bundle exec fastlane beta

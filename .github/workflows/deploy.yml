# .github/workflows/deploy.yml

name: Build with Bazel, Deploy with Fastlane

# Trigger this workflow on every push to the 'main' branch
on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    name: Build and Deploy to TestFlight
    runs-on: macos-latest

    steps:
      # 1. Checkout the repository code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Cache Bazel build artifacts
      # This is a critical performance improvement. It saves the Bazel cache 
      # between runs, so you don't have to redownload dependencies every time.
      - name: Cache Bazel
        uses: actions/cache@v4
        with:
          path: ~/.cache/bazel
          key: ${{ runner.os }}-bazel-${{ hashFiles('**/MODULE.bazel', '**/WORKSPACE', '.bazelversion') }}
          restore-keys: |
            ${{ runner.os }}-bazel-

      # 3. Select the version of Xcode to use
      # Required by Bazel's iOS build rules.
      - name: Select Xcode version
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.2.0'

      # 4. Clean Bazel cache to avoid stale dependencies
      - name: Clean Bazel cache
        run: bazel clean --expunge

      # 4.1. Install iOS Distribution Certificate for Code Signing
      # This step installs the certificate directly into the system keychain for Bazel sandbox access
      - name: Install iOS Distribution Certificate
        env:
          IOS_DIST_SIGNING_KEY: ${{ secrets.IOS_DIST_SIGNING_KEY }}
          IOS_DIST_SIGNING_KEY_PASSWORD: ${{ secrets.IOS_DIST_SIGNING_KEY_PASSWORD }}
        run: |
          echo "🔐 Installing certificate into system keychain for Bazel sandbox access..."
          
          # Create variable for certificate path
          CERTIFICATE_PATH=$RUNNER_TEMP/ios_distribution.p12
          
          # Decode base64 certificate and save to file
          echo "📄 Decoding certificate from secrets..."
          echo -n "$IOS_DIST_SIGNING_KEY" | base64 --decode -o $CERTIFICATE_PATH
          
          # Import certificate directly into system keychain with codesign tool access
          echo "📥 Installing certificate into system keychain..."
          sudo security import $CERTIFICATE_PATH -k /Library/Keychains/System.keychain -P "$IOS_DIST_SIGNING_KEY_PASSWORD" -T /usr/bin/codesign
          
          # Verify certificate installation and show detailed certificate information
          echo "✅ Verifying certificate installation and type..."
          
          # Show all codesigning identities with full details
          echo "📋 All available codesigning identities:"
          security find-identity -v -p codesigning
          
          # Extract certificate details to check type
          echo "🔍 Analyzing installed certificate type..."
          TEMP_CERT_PATH=$RUNNER_TEMP/cert_for_analysis.pem
          openssl pkcs12 -in $CERTIFICATE_PATH -clcerts -nokeys -out $TEMP_CERT_PATH -passin pass:"$IOS_DIST_SIGNING_KEY_PASSWORD"
          INSTALLED_CERT_SUBJECT=$(openssl x509 -in $TEMP_CERT_PATH -noout -subject)
          INSTALLED_CERT_TYPE=$(echo "$INSTALLED_CERT_SUBJECT" | sed -n 's/.*CN = \([^,]*\).*/\1/p')
          
          # Debug: Show what we extracted
          echo "🐛 DEBUG - Subject: $INSTALLED_CERT_SUBJECT"
          echo "🐛 DEBUG - Extracted Type: '$INSTALLED_CERT_TYPE'"
          
          echo "📄 Installed Certificate Details:"
          echo "Subject: $INSTALLED_CERT_SUBJECT"
          echo "Certificate Type: $INSTALLED_CERT_TYPE"
          
          # Check if it's the correct type for TestFlight
          if echo "$INSTALLED_CERT_TYPE" | grep -q "iPhone Distribution"; then
            echo "✅ SUCCESS: Certificate type is 'iPhone Distribution' - correct for TestFlight"
          elif echo "$INSTALLED_CERT_TYPE" | grep -q "iPhone Developer"; then
            echo "❌ ERROR: Certificate type is 'iPhone Developer' - TestFlight requires 'iPhone Distribution'"
            echo "Please export the iOS Distribution certificate from Keychain Access, not the Developer certificate"
            exit 1
          elif echo "$INSTALLED_CERT_TYPE" | grep -q "Apple Distribution"; then
            echo "✅ SUCCESS: Certificate type is 'Apple Distribution' - correct for TestFlight"
          else
            echo "⚠️  WARNING: Unrecognized certificate type: $INSTALLED_CERT_TYPE"
          fi
          
          # Clean up certificate files
          rm -f $CERTIFICATE_PATH $TEMP_CERT_PATH
          
          echo "🎉 Certificate type verification completed!"

      # 4.2. Analyze provisioning profile and verify certificate compatibility
      - name: Verify certificate and provisioning profile compatibility
        run: |
          echo "🔍 Analyzing provisioning profile and certificate compatibility..."
          
          PROVISIONING_PROFILE_PATH="CrossSumsSimple/CrossSumsSimple_AppStore.mobileprovision"
          
          # Extract provisioning profile contents
          echo "📄 Extracting provisioning profile contents..."
          security cms -D -i "$PROVISIONING_PROFILE_PATH" > /tmp/profile.plist
          
          # Show provisioning profile details
          echo "📋 Provisioning Profile Details:"
          echo "Name: $(/usr/libexec/PlistBuddy -c 'Print Name' /tmp/profile.plist)"
          echo "Team ID: $(/usr/libexec/PlistBuddy -c 'Print TeamIdentifier:0' /tmp/profile.plist)"
          echo "Bundle ID: $(/usr/libexec/PlistBuddy -c 'Print Entitlements:application-identifier' /tmp/profile.plist)"
          echo "Expiry: $(/usr/libexec/PlistBuddy -c 'Print ExpirationDate' /tmp/profile.plist)"
          
          # Extract certificate identity from provisioning profile
          echo "🔐 Expected Certificate Identity from Provisioning Profile:"
          /usr/libexec/PlistBuddy -c 'Print DeveloperCertificates:0' /tmp/profile.plist > /tmp/cert.der
          PROVISIONING_CERT_SUBJECT=$(openssl x509 -inform DER -noout -subject -in /tmp/cert.der)
          EXPECTED_IDENTITY=$(echo "$PROVISIONING_CERT_SUBJECT" | sed 's/.*CN = \([^,]*\).*/\1/')
          
          # Debug: Show what we extracted
          echo "🐛 DEBUG - Provisioning Subject: $PROVISIONING_CERT_SUBJECT"
          echo "🐛 DEBUG - Extracted Identity: '$EXPECTED_IDENTITY'"
          echo "Expected: $EXPECTED_IDENTITY"
          
          # Show available certificates in keychain
          echo "🔑 Available Signing Identities in Keychain:"
          security find-identity -v -p codesigning
          
          # Check if expected identity is available
          echo "✅ Checking certificate compatibility..."
          if security find-identity -v -p codesigning | grep -q "$EXPECTED_IDENTITY"; then
            echo "✅ SUCCESS: Found matching certificate identity in keychain!"
            echo "CERTIFICATE_IDENTITY=$EXPECTED_IDENTITY" >> $GITHUB_ENV
          else
            echo "❌ ERROR: Expected certificate identity not found in keychain!"
            echo "Expected: $EXPECTED_IDENTITY"
            echo "Available identities:"
            security find-identity -v -p codesigning
            exit 1
          fi
          
          # Clean up temporary files
          rm -f /tmp/profile.plist /tmp/cert.der
          echo "🎯 Certificate verification completed successfully!"

      # 5. Build IPA with Bazel (for device deployment to TestFlight)
      # The 'Install Bazel' step has been removed. The GitHub runner has 'bazelisk'
      # pre-installed, which will read the .bazelversion file and automatically
      # use the correct version of Bazel for the build.
      - name: Build IPA with Bazel
        run: |
          # Use specific certificate identity if available
          if [ -n "$CERTIFICATE_IDENTITY" ]; then
            echo "🔐 Building with specific certificate identity: $CERTIFICATE_IDENTITY"
            bazel build //CrossSumsSimple:CrossSumsSimple_device_ipa --config=ios_device --xcode_version=16.2.0 --ios_signing_cert_name="$CERTIFICATE_IDENTITY" --verbose_failures
          else
            echo "🔐 Building with default certificate selection"
            bazel build //CrossSumsSimple:CrossSumsSimple_device_ipa --config=ios_device --xcode_version=16.2.0 --verbose_failures
          fi

      # 5.1. Debug - List bazel-bin contents to verify IPA location
      - name: Debug - List bazel-bin contents
        run: |
          echo "Current directory: $(pwd)"
          echo "Contents of bazel-bin:"
          find bazel-bin -name "*.ipa" -type f 2>/dev/null || echo "No .ipa files found in bazel-bin"
          echo "Contents of bazel-bin/CrossSumsSimple (if exists):"
          ls -la bazel-bin/CrossSumsSimple/ 2>/dev/null || echo "bazel-bin/CrossSumsSimple directory not found"

      # 6. Setup Ruby and Fastlane
      # This installs Ruby and your project's gems (like fastlane) from the Gemfile.
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler: '2.4'
          working-directory: ./fastlane # Specifies where to find the Gemfile

      # 7. Install Fastlane gems (explicit step to ensure they're available)
      - name: Install Fastlane gems
        working-directory: ./fastlane
        run: bundle install

      # 7.1. Find and set IPA path dynamically with robust fallback
      - name: Find IPA file and set path
        id: find_ipa
        run: |
          echo "=== IPA File Discovery Debug ==="
          echo "Current directory: $(pwd)"
          echo "Checking if bazel-bin is a symlink:"
          ls -la bazel-bin 2>/dev/null || echo "bazel-bin not found"
          
          # Method 1: Try the known direct path first
          DIRECT_PATH="bazel-bin/CrossSumsSimple/CrossSumsSimple_device_ipa.ipa"
          if [ -f "$DIRECT_PATH" ]; then
            echo "✅ Found IPA using direct path: $DIRECT_PATH"
            echo "IPA_PATH=$DIRECT_PATH" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Method 2: Use find with symlink following
          echo "Direct path failed, trying find with -L flag..."
          IPA_FILE=$(find bazel-bin -L -name "*.ipa" -type f 2>/dev/null | head -1)
          if [ -n "$IPA_FILE" ]; then
            echo "✅ Found IPA using find -L: $IPA_FILE"
            echo "IPA_PATH=$IPA_FILE" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Method 3: Manual directory traversal
          echo "Find command failed, trying manual discovery..."
          if [ -d "bazel-bin/CrossSumsSimple" ]; then
            echo "Contents of bazel-bin/CrossSumsSimple:"
            ls -la bazel-bin/CrossSumsSimple/
            
            # Look for device IPA files in the directory
            for file in bazel-bin/CrossSumsSimple/*device_ipa*.ipa; do
              if [ -f "$file" ]; then
                echo "✅ Found IPA using manual discovery: $file"
                echo "IPA_PATH=$file" >> $GITHUB_OUTPUT
                exit 0
              fi
            done
          fi
          
          # Method 4: Last resort - search entire bazel output
          echo "Manual discovery failed, searching entire bazel output..."
          for file in bazel-bin/**/*.ipa bazel-out/**/*.ipa; do
            if [ -f "$file" ]; then
              echo "✅ Found IPA in bazel output: $file"
              echo "IPA_PATH=$file" >> $GITHUB_OUTPUT
              exit 0
            fi
          done
          
          # All methods failed - provide detailed error information
          echo "❌ All IPA discovery methods failed!"
          echo "=== Debug Information ==="
          echo "bazel-bin structure:"
          find bazel-bin -type f -name "*ipa*" 2>/dev/null || echo "No files with 'ipa' in name found"
          echo "Available files:"
          find bazel-bin -type f | head -20
          exit 1

      # 7.2. Run Fastlane to Deploy
      # This step runs inside the `./fastlane` directory.
      - name: Upload to TestFlight
        working-directory: ./fastlane
        env:
          # Secrets for authenticating with App Store Connect
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY_CONTENT }}
          
          # Pass the dynamically found IPA path as absolute path to avoid relative path issues
          FASTLANE_IPA_PATH: ${{ github.workspace }}/${{ steps.find_ipa.outputs.IPA_PATH }}
        run: bundle exec fastlane beta
